---
title: "Command Specifications - Page 7"
description: "Items 301-350 of 1103 command specifications"
---

# Command Specifications - Page 7

Showing items **301-350** of **1103**

[← Previous](command-page-005) | Page 7 of 23 | [Next →](command-page-007)

---

## 301. Command: `\pgfparsetime\marg{time`

**ID**: `d0c47d84e073`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command works like || (indeed, it calls is internally), but returns the result in the macro || rather than ||. Furthermore, the following changes are installed: itemize The postfix operator |s| is added, which has no effect. The postfix operator |ms| is added, which divides a number by 1000, so |2ms| equals 0.002s. The postfix operator |min| is added, which multiplies a number by 60. The postfix operator |h| is added, which multiplies a number by 3600. The infix operator |:| is redefined,

---

## 302. Command: `\pgfsnapshot\marg{time`

**ID**: `5888b764c9ed`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; When this command is used inside a \ scope, the behavior of || changes: Instead of adding an animation to the object and the attribute, the object's attribute is set to value it would have during the animation at time time. Note that when this command is used in a \ scope, no animation is created and no support by the driver is needed (so, it works with pdf). codeexample[preamble=&#123;animations&#125;] [make snapshot of=1s, animate = &#123; myself: = &#123; :rotate = &#123; 0s = "0", 2s = "90" &#125;, :color = &#123; 0s = "red

---

## 303. Command: `\pgfsnapshotafter\marg{time`

**ID**: `81c62b98e663`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command works exactly like || only the ``moment'' that time refers to is conceptually $time + $: When timeline specifies several values for time, this command will select the last value at time, while || will select the first value at time. Similarly, when a timeline ends at time, || will select the last value of the timeline while || will not apply the animation any more: codeexample[preamble=&#123;animations&#125;] in &#123;0,1,2,3,4&#125; &#123; :rotate = &#123; 0s = "0", 2s = "90", 2s = "180", 4s = "270" &#125; [draw=b

---

## 304. Command: `\graph`

**ID**: `79f8f779c764`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: Inside a |&#123;tikzpicture&#125;| this is an abbreviation for | graph|.

---

## 305. Command: `\tikzgraphsset\marg{options`

**ID**: `01fad7f71690`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; Executes the options with the path prefix |/tikz/graphs|.

---

## 306. Command: `\tikzgraphnodetext`

**ID**: `e2a434332dd4`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This macro expands to the text to the right of the double underscore or slash in a direct node specification or, if there is no slash, to the node name.

---

## 307. Command: `\tikzgraphnodename`

**ID**: `2ffd512bbadb`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This macro expands to the name of the current node without the path.

---

## 308. Command: `\tikzgraphnodepath`

**ID**: `4bc55a041bb7`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This macro expands to the current path of the node. These paths result from the use of the |name| key as described above.

---

## 309. Command: `\tikzgraphnodefullname`

**ID**: `f8b939bd52cf`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This macro contains the concatenation of the above two.

---

## 310. Command: `\tikzgraphforeachcolorednode\marg{color name`

**ID**: `a236be143e1a`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: macro&#125; When this command is called inside code, the following will happen: \ will iterate over all nodes inside the just-specified group that have the color color name. The order in which they are iterated over is the order in which they appear inside the group specification (if a node is encountered several times inside the specification, only the first occurrence counts). Then, for each node the macro is executed with the node's name as the only argument. In the following example we use an ope

---

## 311. Command: `\tikzgraphpreparecolor\marg{color name`

**ID**: `f23de383b452`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: counterprefix&#125; This command is used to ``prepare'' the nodes of a certain color for random access. The effect is the following: It is counted how many nodes there are having color color name in the current group and the result is stored in counter. Next, macros named prefix|1|, prefix|2|, and so on are defined, that store the names of the first, second, third, and so on node having the color color name. The net effect is that after you have prepared a color, you can quickly iterate over them. Th

---

## 312. Command: `\pgfdeclarepatternformonly%
    \opt{\oarg{variables`

**ID**: `0b7bfe0f7233`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; name bottom left top right tile size code &#125; This command declares a new form-only pattern. The name is a name for later reference. The two parameters lower left and upper right must describe a bounding box that is large enough to encompass the complete tile. The size of a tile is given by tile size, that is, a tile is a rectangle whose lower left corner is the origin and whose upper right corner is given by tile size. This might make you wonder why the second and third parameters are needed. F

---

## 313. Command: `\pgfdeclarepatterninherentlycolored
    \opt{\oarg{variables`

**ID**: `661696f34396`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; name lower left upper right tile size code &#125; This command works like ||, only the pattern will have an inherent color. To set the color, you should use 's color commands, not the || command, since this fill is not protocolled. codeexample[preamble=&#123;patterns&#125;] green stars &#123;&#125;&#123;1cm&#123;1cm&#125;&#125; &#123;1cm&#123;1cm&#125;&#125; &#123; green!50!black &#123;.5cm&#123;.5cm&#125;&#125; &#123;0&#123;4mm&#125;&#125; &#123;144&#123;4mm&#125;&#125; &#123;288&#123;4mm&#125;&#125; &#123;72&#123;4mm&#125;&#125; &#123;216&#123;4mm&#125;&#125; stroke,fill &#125; tikzpicture [pattern=green stars] (0,0) rectangle (3,2); tikzpicture codeexample

---

## 314. Command: `\pgfsetfillpattern\marg{name`

**ID**: `495892897a24`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: color&#125; This command specifies that paths that are filled should be filled with the ``color'' by the pattern name. For an inherently colored pattern, the color parameter is ignored. For form-only patterns, the color parameter specifies the color to be used for the pattern. codeexample[ preamble=&#123;patterns stars &#123;&#125;&#123;1cm&#123;1cm&#125;&#125; &#123;1cm&#123;1cm&#125;&#125; &#123; &#123;.5cm&#123;.5cm&#125;&#125; &#123;0&#123;4mm&#125;&#125; &#123;144&#123;4mm&#125;&#125; &#123;288&#123;4mm&#125;&#125; &#123;72&#123;4mm&#125;&#125; &#123;216&#123;4mm&#125;&#125; fill &#125; green stars &#123;&#125;&#123;1cm&#123;1cm&#125;&#125; &#123;1cm&#123;1cm&#125;&#125; &#123; green!50!black &#123;.5cm&#123;.5cm&#125;&#125; &#123;0&#123;4mm&#125;&#125; &#123;144&#123;4mm&#125;&#125; &#123;288&#123;

---

## 315. Command: `\pgfplotstreamstart`

**ID**: `5df470c46527`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This command signals that a plot stream starts. The effect of this command is to call the internal command |@plotstreamstart|, which is set by the current plot handler to do whatever needs to be done at the beginning of the plot. It will also reset the meaning of the internal commands like |@plotstreampoint| to the initial setting for the plot handler (what this means will be explained in a moment).

---

## 316. Command: `\pgfplotstreampoint\marg{point`

**ID**: `ceb86c16b8f0`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command adds a point to the current plot stream. The effect of this command is to call the internal command |@plotstreampoint|, which is also set by the current plot handler. This command should now ``handle'' the point in some sensible way. For example, a line-to command might be issued for the point. When a plot handler is installed, it will setup the internal command |@plotstreampoint| in some way. It is permissible to change the meaning of this internal command during a stream. For in

---

## 317. Command: `\pgfplotstreampointoutlier\marg{point`

**ID**: `a79f9d278944`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; An outlier is a point that is ``out of bounds'' in some way. For instance, it might have very large coordinates or the coordinates might just be outside some specified range. Nevertheless, an outlier is still a well-defined point. This command is issued, for instance, by gnuplot when a value is outside the specified range. You can configure how outliers are treated using the following key: key&#123;/pgf/handle outlier points in plots=how (initially jump)&#125; tikz You can set how to one of the followin

---

## 318. Command: `\pgfplotstreampointundefined`

**ID**: `2fe9463186af`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This command indicated that the stream contains an ``undefined'' point like a point where some coordinate results for a division by zero. Such a point cannot be plotted, which is why it is not given as a parameter. However, such a point can result in a jump in the plot, depending on the setting of the following key: key&#123;/pgf/handle undefined points in plots=how (initially jump)&#125; tikz You can set how to one of the following values: itemize |ignore| The undefined point will be completely ignored, 

---

## 319. Command: `\pgfplotstreamnewdataset`

**ID**: `38d7369f1126`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This command indicated that in the stream a ``new data set'' starts. So, the stream does not end, but there is a logical break in the data. For example, when a table is read from a file, empty lines are interpreted as indicating new data sets. What happens when a new data set is encountered is governed by the following key: key&#123;/pgf/handle new data sets in plots=how (initially jump)&#125; tikz You can set how to one of the following values: itemize |ignore| The command will be completely ignored, jus

---

## 320. Command: `\pgfplotstreamspecial\marg{text`

**ID**: `cc91c576c727`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command causes |@plotstreamspecial| to be called with text as its parameter. This allows handler-specific information to be passed to the handler. All normal handlers ignore this command.

---

## 321. Command: `\pgfplotstreamend`

**ID**: `63cfe2e53b5d`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This command signals that a plot stream ends. It calls |@plotstreamend|, which should now do any necessary ``cleanup''.

---

## 322. Command: `\pgfplotxyfile\marg{filename`

**ID**: `ba9e87eadef6`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command will try to open the file filename. If this succeeds, it will convert the file contents into a plot stream as follows: A || is issued. Then, for each empty line a || is produced. Other lines in the file should start with two numbers separated by a space, such as |0.1 1| or |100 -.3|. The numbers may be followed by some text, which will be ignore except if it is exactly ``|u|'' or ``|o|''. For ``|u|'' the point is considered to be undefined and || is called. For ``|o|'' the point i

---

## 323. Command: `\pgfplotxyzfile\marg{filename`

**ID**: `5e2d1ffd1a9b`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command works like ||, only three numbers are expected on each non-empty line. They are converted into points in the $xyz$-coordinate system. Consider, the following file: codeexample[code only, tikz syntax=false] # more comments 2 -5 1 first entry 2 -.2 2 o 2 -5 2 third entry codeexample It is turned into the following stream: codeexample[code only] &#123;2&#123;-5&#125;&#123;1&#125;&#125; &#123;2&#123;-.2&#125;&#123;2&#125;&#125; &#123;2&#123;-5&#125;&#123;2&#125;&#125; codeexample

---

## 324. Command: `\pgfplotfunction\marg{variable`

**ID**: `1d542e73e362`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: sample listpoint&#125; This command will produce coordinates by iterating the variable over all values in sample list, which should be a list in the || syntax. For each value of variable, the point is evaluated and the resulting coordinate is inserted into the plot stream. codeexample[] tikzpicture[x=3.8cm/360] &#123;0,5,...,360&#125;&#123;&#123;sin()+sin(3*)&#125;&#125; stroke tikzpicture codeexample codeexample[] tikzpicture[y=3cm/360] &#123;0,5,...,360&#125;&#123;sin(2*)&#123;&#125;&#123;cos(2*)&#125;&#125; stroke tikzpicture codeexample Be warned that if the expres

---

## 325. Command: `\pgfplotgnuplot\oarg{prefix`

**ID**: `b9dff3cb8b3f`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: function&#125; This command will ``try'' to call the gnuplot program to generate the coordinates of the function. In detail, the following happens: This command works with two files: prefix|.gnuplot| and prefix|.table|. If the optional argument prefix is not given, it is set to ||. Let us start with the situation where none of these files exists. Then \ will first generate the file prefix|.gnuplot|. In this file it writes codeexample[code only, tikz syntax=false] set table "#1.table"; set format " co

---

## 326. Command: `\pgfplothandlerlineto`

**ID**: `885aaa1312ce`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This handler will issue a || command for each point of the plot, except possibly for the first. What happens with the first point can be specified using the two commands described below. codeexample[] pgfpicture &#123;1cm&#123;0cm&#125;&#125; &#123;2cm&#123;1cm&#125;&#125; &#123;3cm&#123;2cm&#125;&#125; &#123;1cm&#123;2cm&#125;&#125; stroke pgfpicture codeexample

---

## 327. Command: `\pgfsetmovetofirstplotpoint`

**ID**: `18cc684bc78c`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: Specifies that the line-to plot handler (and also some other plot handlers) should issue a move-to command for the first point of the plot instead of a line-to. This will start a new part of the current path, which is not always, but often, desirable. This is the default.

---

## 328. Command: `\pgfsetlinetofirstplotpoint`

**ID**: `3d0538fe7382`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: Specifies that plot handlers should issue a line-to command for the first point of the plot. codeexample[] pgfpicture &#123;1cm&#123;0cm&#125;&#125; &#123;2cm&#123;1cm&#125;&#125; &#123;3cm&#123;2cm&#125;&#125; &#123;1cm&#123;2cm&#125;&#125; stroke pgfpicture codeexample

---

## 329. Command: `\pgfplothandlerpolygon`

**ID**: `f59ff192ea81`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This handler works like the line-to plot handler, only the line is closed at the end using ||, resulting in a polygon.

---

## 330. Command: `\pgfplothandlerdiscard`

**ID**: `9212df2dcb16`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This handler will simply throw away the stream.

---

## 331. Command: `\pgfplothandlerrecord\marg{macro`

**ID**: `b73e7a777ac5`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; When this handler is installed, each time a plot stream command is called, this command will be appended to macro. Thus, at the end of the stream, macro will contain all the commands that were issued on the stream. You can then install another handler and invoke macro to ``replay'' the stream (possibly many times). codeexample[] pgfpicture &#123;1cm&#123;0cm&#125;&#125; &#123;2cm&#123;1cm&#125;&#125; &#123;3cm&#123;1cm&#125;&#125; &#123;1cm&#123;2cm&#125;&#125; stroke pgfpicture codeexample

---

## 332. Command: `\pgfdeclareplothandler\marg{macro`

**ID**: `ba2aee1ca711`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: argumentsconfiguration&#125; This command creates a new plot handler that can subsequently be called using the macro macro. This macro take the arguments given in arguments, which can be a list like |#1#2| if macro should be invoked with two arguments. Here is a typical example: codeexample[code only] &#123;#1&#125;&#123;...&#125; ... foo ... codeexample The configuration is used to define the behavior of the handler. It is a list of key--value pairs, where the following keys are allowed: itemize |start=|code. The code 

---

## 333. Command: `\pgfgdbeginscope`

**ID**: `d9e9318bec2e`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This macro starts a \ scope inside which the following things happen: enumerate The display layer method |beginGraphDrawingScope| is called, which created a new graph drawing scope inside the graph drawing system and places it on top of an internal stack. From now on, all subsequent interface calls will refer to this scope until || is called, which will pop the scope once more. Inside the \ scope, nodes are not placed immediately. Rather, ||, see Section~section-shapes-deferred-node-positioning,

---

## 334. Command: `\pgfgdendscope`

**ID**: `d1c40eb9be7e`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This macro is used to end a graph drawing scope. It must be given on the same \ grouping level as the corresponding ||. When the macro is called, it triggers a lot of new calls: enumerate The special treatment of newly created boxes is ended. Nodes are once more created normally. The effects of the code that was inserted via the specification hook command also ends (provided it had no global effects). We call |InterfaceToDisplay.runGraphDrawingAlgorithm|. This will cause the algorithm(s) for the

---

## 335. Command: `\pgfgdedge\marg{first node`

**ID**: `2da9d45f17a6`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: second nodeedge directionedge optionsedge nodes&#125; This command is used to tell the graph drawing engine that there is an edge between first node and second node in your graph. The ``kind'' of connection is indicated by direction, which may be one of the following: itemize |-&gt;| indicates a directed edge (also known as an arc) from first node to second node. |--| indicates an undirected edge between first node and second node, |&lt;-| indicates a directed edge from second node to first node, but with 

---

## 336. Command: `\pgfgdsetedgecallback\marg{macro`

**ID**: `c0319807db36`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command allows you to change the macro that gets called form inside the graph drawing system at the end of the creation of a graph, when the nodes have been positioned. The macro will be called once for each edge with the following parameters: quote macrofirst nodesecond nodedirectionedge optionsedge nodes\\ algorithm-generated optionsbend informationanimations quote The first five parameters are the original values that were passed down to the || command. The algorithm-generated options 

---

## 337. Command: `\pgfgdbeginlayout`

**ID**: `a46f7e75beb8`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This command first starts a new \ scope and then informs the display layer that a new (sub)layout should be started. For each graph there may be a hierarchy of layouts, each of which contains a certain number of vertices and edges. This hierarchy is created through calls to this macros and the corresponding calls of ||. For each graph drawing scope there has to be exactly one main layout that encompasses all nodes and edges and also all sublayouts. Thus, after a graph drawing scope has been open

---

## 338. Command: `\pgfgdendlayout`

**ID**: `25196ec95670`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: This command ends the \ scope of the current layout. Once closed, no nodes or edges can be added to a layout.

---

## 339. Command: `\pgfgdsetlatenodeoption\marg{node name`

**ID**: `e9e6dd3f1d43`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command can only be called when the node named node name has already been created inside the current graph drawing scope. The effect of calling this macro will be that all options currently on the graph drawing system's option stack will be added to the node's option, possibly overwriting the original option settings. Furthermore, the node will become part of all layouts currently on the option stack. This means that you can use this command to add a node to several layouts that are not i

---

## 340. Command: `\pgfgdsetrequestcallback\marg{macro`

**ID**: `55684a3a30ca`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; This command sets up macro as the macro that is called whenever a layout key ``requests'' that a layout and, possibly, a graph drawing scope is opened. When macro is called, it gets two parameters, the begin code and the end code. In addition to whatever setup the macro would like to do, it should execute the begin code at the beginning of a \ scope (the code will open graph drawing and layout scopes) and the end code at the end of the same \ scope. The need for this slightly strange macro ari

---

## 341. Command: `\pgfgdevent\marg{kind`

**ID**: `bfe83b1a8fde`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: parameter&#125; Calls |createEvent| of the graph drawing system's interface class. This creates a new |Event| object on the Lua layer whose |kind| field is set to kind and the |parameters| field to parameter. You must be inside a graph drawing scope to use this command.

---

## 342. Command: `\pgfgdbegineventgroup\marg{parameter`

**ID**: `4a2fb527e220`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; Starts an event group. This just means that an |Event| of kind |begin| is created with the given parameter.

---

## 343. Command: `\pgfgdendeventgroup`

**ID**: `7281661fa600`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: Ends an event group. This is done by adding an event of kind |end| without any parameters to the event string.

---

## 344. Command: `\pgfgdeventgroup\marg{parameters`

**ID**: `6d86401476a9`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; Starts an event group just like ||, but adds a corresponding closing |end| event at the end of the current \ group (using ||).

---

## 345. Command: `\pgfgdsubgraphnode\marg{name`

**ID**: `0dac6d0d5ad6`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: node optionsnode text&#125; A subgraph node is a node that ``surrounds'' the nodes of a subgraph. The special property of a subgraph node opposed to a normal node is that it is created only after the subgraph has been laid out. However, the difference to a collection like |hyper| is that the node is available immediately as a normal node in the sense that you can connect edges to it. What happens internally is that subgraph nodes get ``registered'' immediately both on the \ level and on the Lua level

---

## 346. Command: `\pgfmathreciprocal\marg{x`

**ID**: `f09ef3cdcc96`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#125; Defines || as $1$. This provides greatest accuracy when x is small.

---

## 347. Command: `\pgfmathapproxequalto\marg{x`

**ID**: `531ff955045e`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: y&#125; Defines || 1.0 if $ x - y &lt; 0.0001$, but 0.0 otherwise. As a side-effect, the global boolean || will be set accordingly.

---

## 348. Command: `\pgfmathgeneratepseudorandomnumber`

**ID**: `d5ceceaee0ea`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: Defines || as a pseudo-random integer between 1 and $2^&#123;31&#125;-1$. This uses a linear congruency generator, based on ideas of Erich Janka.

---

## 349. Command: `\pgfmathrandominteger\marg{macro`

**ID**: `671522197f00`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: minimummaximum&#125; This defines macro as a pseudo-randomly generated integer from the range minimum to maximum (inclusive). codeexample[] pgfpicture in &#123;1,...,50&#125;&#123; &#123;1&#125;&#123;50&#125; &#123;1&#125;&#123;50&#125; &#123;+ pt&#123;+ pt&#125;&#125;&#123;+2pt&#125; blue!40!white blue!80!black stroke, fill &#125; pgfpicture codeexample

---

## 350. Command: `\pgfmathdeclarerandomlist\marg{list name`

**ID**: `8d519e2a6b18`  
**Package**: tikz-pgf  
**Type**: Command Specification  

**Description**: &#123;\&#123;&#125;item-1item-2...&#123;\&#125;&#125;&#125; This creates a list of items with the name list name.

---


[← Previous](command-page-005) | Page 7 of 23 | [Next →](command-page-007)
