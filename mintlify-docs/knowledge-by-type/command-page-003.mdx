---
title: "Command Specifications - Page 4"
description: "Items 151-200 of 1103 command specifications"
---

# Command Specifications - Page 4

Showing items **151-200** of **1103**

[← Previous](command-page-002) | Page 4 of 23 | [Next →](command-page-004)

---

## 151. Command: `\let\meta{\textbackslash newmacro`

**ID**: `5069afa73d2d`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: =token&#125; Defines or redefines || to be an equivalent to token. For example, |=| will create a new copy of macro ||. The copy is named ||, and it will have exactly the same replacement text and argument pattern as ||. It is also possible that token is something different than a macro, for example a named register or a single character.

---

## 152. Command: `\gdef\meta{\textbackslash macroname`

**ID**: `d11546c58ea6`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: argument patternreplacement text&#125; A shortcut for ||. It defines || globally, independent of the current scope. You should avoid macros which exist in both, the global namespace and a local scope, with different meanings. Section~sec:scopes explains more about scoping.

---

## 153. Command: `\xdef\meta{\textbackslash macroname`

**ID**: `4ea5a75a4ab6`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: argument patternreplacement text&#125; A shortcut for ||. It defines || globally, independent of the current scope. You should avoid macros which exist in both, the global namespace and a local scope, with different meanings. Section~sec:scopes explains more about scoping.

---

## 154. Command: `\csname\meta{expandable tokens`

**ID**: `e0fe23a1840e`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: endcsname&#125; This command is not a macro definition, it is a definition of a macro's name. The ``cs'' means ``control sequence''. The ||, || pair defines a control sequence name (a macro name) using expandable tokens. The control sequence character `|\|' will be prepended automatically by ||.In fact, the contents of &#123; escapechar will be used here. If its value is -1, no character will be prepended. The same holds for any occurrence where a backslash would be inserted by \ commands.&#125; codeexample[] 

---

## 155. Command: `\string\meta{\textbackslash macro`

**ID**: `c4338a7af23f`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; This command does not define a macro. Instead, it returns a macro's name as a sequence of separate tokens, including the control sequence token `|\|'. codeexample[] I have just defined `' using `'. codeexample You can also use || on other tokens -- for example characters. That doesn't hurt, the character will be returned as-is.

---

## 156. Command: `\message\marg{tokens`

**ID**: `9969cdba1863`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125;

---

## 157. Command: `\meaning\meta{\textbackslash macro`

**ID**: `aabf90de330c`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125;

---

## 158. Command: `\tracingmacros=2`

**ID**: `01c519a17383`  
**Package**: pgfplots  
**Type**: Command Specification  

---

## 159. Command: `\tracingcommands=2`

**ID**: `417b52180800`  
**Package**: pgfplots  
**Type**: Command Specification  

---

## 160. Command: `\tracingrestores=1`

**ID**: `155aa8be6b99`  
**Package**: pgfplots  
**Type**: Command Specification  

---

## 161. Command: `\begingroup`

**ID**: `1dd1146065f0`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: Starts a new \ group (a local scope). The scope will be active until it will be closed by ||. The || command can occur later in the main token list.

---

## 162. Command: `\endgroup`

**ID**: `68d36fabec55`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: Ends a \ group which has been opened with ||.

---

## 163. Command: `\bgroup`

**ID**: `90c19501e2da`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: A special variant of || which can also be used to delimit arguments to || or || (i.e. it avoids the necessity to provide matched curly braces in this context). The || macro is also useful to test whether the next following character is an opening brace (see ||). If one just needs to open a \ group, one should prefer ||.

---

## 164. Command: `\egroup`

**ID**: `44e4ccf26741`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: Closes a preceding ||.

---

## 165. Command: `\global\meta{definition or assignment`

**ID**: `1a9bb4246adf`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; The definition which follows || immediately will be done globally. codeexample[code only] &#123; 123 0 by3 0=&#123;34&#125; &#125; codeexample

---

## 166. Command: `\globaldefs=\mchoice{-1,0,1`

**ID**: `f8454be07a73`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: (initially 0)&#125; I cite from~texbook: ``If the || parameter is positive at the time of an assignment, a prefix of || is automatically implied; but if || is negative at the time of the assignment, a prefix of || is ignored. If || is zero (which it usually is), the appearance of nonappearance of || determines whether or not a global assignment is made.''

---

## 167. Command: `ifnum\meta{count/integer number`

**ID**: `4c4155999893`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: =count/integer numbertrue-block elsefalse-block fi&#125; || compare integer numbers or integer registers (|| registers) and contains two branches, one is executed in the true case, the other in the case of false: codeexample[] 1=2 This is shown if above were true. This is shown if above results to false. codeexample Note that the || with its false-block is optional.

---

## 168. Command: `ifdim\meta{dimen/fixed point number`

**ID**: `017deb7eca61`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: =dimen/fixed point numbertrue-block elsefalse-block fi&#125; Similar to ||, || compares two fixed point numbers or || registers. The numbers must have a unit. codeexample[] 1pt=2pt This is shown if above were true. This is shown if above results to false. codeexample

---

## 169. Command: `ifx\meta{token1`

**ID**: `697c85da0b19`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: token2true-block elsefalse-block fi&#125; || is a bit more complex: It compares two tokens up to their first-level expansion. codeexample[] This is shown if the two tokens have equal expansion. This is shown if the two tokens expand to something different. codeexample Here, we have defined a token || to be a replacement for || and subsequently have compared whether these two tokens are equal in first-level expansion. Note that the definition is actually nonsense. If ever were to go through the whole 

---

## 170. Command: `if\meta{token1`

**ID**: `39cd67f17c22`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: token2true-block elsefalse-block fi&#125; The || comparison is closely related to the || conditional, with one major exception: it expands tokens until it finds the next two unexpandable tokens. If these two tokens are the same, it expands to the true-block, otherwise to the false-block. The || conditional should be handled with care as it might produce undesirable effects. Use it only if you know what you do. A useful example is if you know that a macro contains at most one character, and you want t

---

## 171. Command: `iftrue\meta{true-block`

**ID**: `717522014899`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: elsefalse-block fi&#125; A ``conditional'' which always invokes the true-block.

---

## 172. Command: `iffalse\meta{true-block`

**ID**: `b4461ea18424`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: elsefalse-block fi&#125; A ``conditional'' which always invokes the false-block.

---

## 173. Command: `\newif\meta{if-name`

**ID**: `27b058ddb7e5`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; You can declare a new ``boolean variable `|| by means of ||. Afterwards, you can use the || and || switches to assign the boolean and || to check it. The if-name has to start with || (to support scans for nested |...| pairs, see below).

---

## 174. Command: `\pgfkeyssetvalue\marg{/key path/key name`

**ID**: `3415cf3601de`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: value&#125; This macro (re)defines a key. It is (almost) equivalent to a macro definition of sorts | key@|/key path/key name||value; i.e.\ it stores value into a new macro such that the key can be looked up in constant time in 's hash map. Note that in contrast to other key--value packages like |xkeyval|, the low--level macro name which is used to store the value is not part of the Keys that &#123;key@ is unrelated to Keys.&#125; -- use || and its friends to access the value. The only limit for the number of p

---

## 175. Command: `\pgfkeysgetvalue\marg{/key path/key name`

**ID**: `313fe979eec4`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: macro&#125; As you might have guessed, this macro allows to retrieve the value for some key and store it into macro. Now that we have read about || and ||, we can also provide an example: codeexample[] /notes/key&#123;abc&#125; /notes/key The value of key /notes/key is `'. codeexample There is few magic around these two keys; it is just like a hashmap access with some special naming convention for the keys (due to the key path). Note that since ``hashmap access'' is what \ does all the time when it handles mac

---

## 176. Command: `\pgfkeyslet\marg{/key path/key name`

**ID**: `dde4b2c12b86`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: macro&#125; This is essentially the same as ||, except that the key's value is already available inside of macro: codeexample[] /notes/key&#123;&#125; /notes/key The value of key /notes/key is `'. codeexample Just like || boils down to ||, || boils down to ||.

---

## 177. Command: `\pgfkeysvalueof\marg{/key path/key name`

**ID**: `967cfc350283`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; This is essentially the same as ||/key path/key name macro macro; i.e.\ it expands to the value stored in a key. codeexample[] /notes/key&#123;abc&#125; The value of key /notes/key is `/notes/key'. codeexample However, this key has one major advantage: it can be used inside of an || (because it is fully expandable): codeexample[] /notes/key&#123;abc&#125; --- &#123;/notes/key ---&#125; The value of key /notes/key along with dashes is . codeexample It boils down to a suitable | ... |. Consequently, it expands to || if the k

---

## 178. Command: `\pgfkeysdef\marg{/key path/key name`

**ID**: `d1abda350970`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: macro body&#125; This is a variant of ||. However, it has a substantial difference which appears to be unmotivated as long as we discuss the low--level . It defines a so--called code--key. Code--keys are executable macros. They take an argument, and they do something with it. ``Assigning values'' to such a key is equivalent to invoking macro body in a ``suitable'' way. The result of this macro call is a new key named /key path/key name/|.@cmd|. That key, in turn, is stored as executable macro. The ma

---

## 179. Command: `\pgfkeys\marg{comma--separated key--value pairs`

**ID**: `4dcd7a576878`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; This key constitutes the public \ of Keys. It accepts any number of key--value pairs, separated by commas.

---

## 180. Command: `\pgfkeysalso\marg{comma--separated key--value pairs`

**ID**: `8055c3647ccc`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; This macro is almost the same as ||comma--separated key--value pairs. In fact, if any assignments in its argument use fully--qualified paths (as we did so far in this document), both invocations are equivalent. The difference is how they treat keys which are relative to some current key path, a concept which will be explained in the next subsection. Here is the difference between the macros: || resets the current key path to |/| before processing its argument whereas || does not change the cur

---

## 181. Command: `\addplot\oarg{options`

**ID**: `6484b59249ea`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: input data trailing path commands;&#125; This is the main plotting command, available within each axis environment. It can be used one or more times within an axis to add plots to the current axis. There is also an 3 command which is described in Section~sec:3d. It reads point coordinates from one of the available input sources specified by input data, updates limits, remembers options for use in a legend (if any) and applies any necessary coordinate transformations (or logarithms). The options can b

---

## 182. Command: `\thisrow\marg{column name`

**ID**: `d96c54059f7d`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; Yields the value of the column designated by column name. There is no limit on the number of columns which can be part of a mathematical expression, but only values inside of the currently processed table row can be used. It is possible to provide column aliases for column name as described in the manual of . The argument column name has to denote either an existing column or one for which a column alias exists (see the manual of ). If it can't be resolved, the math parser yields an ``Unknown 

---

## 183. Command: `\thisrowno\marg{column index`

**ID**: `27bcf944e4a8`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; Similar to ||, this command yields the value of the column with index column index (starting with $0$). Limitations: see limitations for ||.

---

## 184. Command: `\coordindex`

**ID**: `b19a5a31ac57`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: Yields the current index of the table row (starting with $0$). This does not count header or comment lines.

---

## 185. Command: `\lineno`

**ID**: `8d006ce97625`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: Yields the current line number (starting with $0$). This does also count header and comment lines.

---

## 186. Command: `\pgfplotsset\marg{key-value-list`

**ID**: `d5ec4135cb6b`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; Defines or sets all options in key-value-list. The key-value-list can contain any of the options in this manual which have the prefix |/pgfplots/| (however, you do not need to type that prefix). Inside of key-value-list, the prefixes `|/pgfplots/|' which are commonly presented in this manual can be omitted (they are checked automatically). This command can be used to define default options for the complete document or a part of the document. For example, codeexample[code only] cycle list=&#123; &#123;re

---

## 187. Command: `\pgfplotstableset\marg{key-value-options`

**ID**: `c764acb1203f`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; The user interface of this package is based on key-value-options. They determine what to display, how to format and what to compute. Key--value pairs can be set in two ways: enumerate As default settings for the complete document (or maybe a part of the document), using ||options. For example, the document's preamble may contain codeexample[code only] fixed zerofill,precision=3 codeexample to configure a precision of $3$ digits after the period, including zeros to get exactly $3$ digits for al

---

## 188. Command: `\pgfplotstabletypeset\oarg{optional arguments`

**ID**: `2d8c3b1395e4`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: file name &#123; or macro &#123; or&#125; inline table&#125;&#125; Loads (or acquires) a table and typesets it using the current configuration of number formats and table options. In case the first argument is a file name, the table will be loaded from disk. If it is an already loaded table (see || or ||), it will be used. Otherwise, if it is inline table data, this data will be parsed just as if it was found in a file (see ||). codeexample[] [sci zerofill]&#123; a b 5000 1.234e5 6000 1.631e5 7000 2.1013e5 9000 1000000 &#125; cod

---

## 189. Command: `\pgfplotstabletypesetfile\oarg{optional arguments`

**ID**: `207dd1519f6f`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: file name&#125; Loads the table file name and typesets it. As of 1.2, this command is an alias to ||, that means the first argument can be either a file name or an already loaded table.

---

## 190. Command: `\pgfplotstablecol`

**ID**: `378069b6a476`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: During the evaluation of row or column options, this command expands to the current column's index.

---

## 191. Command: `\pgfplotstablecolname`

**ID**: `270331f6f418`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: During the evaluation of column options, this command expands to the current column's name. It is valid while || processes the column styles (including the preprocessing step explained in Section~sec:pgfplotstable:preproc), prepares the output cell content and checks row predicates.

---

## 192. Command: `\pgfplotstablerow`

**ID**: `c586ac09991d`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: pgfplotstable:page:tablerow During the evaluation of row or column options, this command expands to the current row's index. ``Evaluation of column options'' applies to any of the styles in Section~sec:data:processing, i.e.\@ preprocessing, typesetting, and postprocessing. The macro || can take any of the values $0,1,2,,n-1$ where $n$ is the value of ||. ``Evaluation of row options'' applies to stuff like |every last row|. Note that it will have the special value $-1$ for the header row.

---

## 193. Command: `\pgfplotstablecols`

**ID**: `38754746e209`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: During the evaluation of row or column options, this command expands to the total number of columns in the output table.

---

## 194. Command: `\pgfplotstablerows`

**ID**: `5a61e9bebcc9`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: During evaluation of columns, this command expands to the total number of input rows. You can use it inside of |row predicate|. During evaluation of rows, this command expands to the total number of output rows.

---

## 195. Command: `\pgfplotstablename`

**ID**: `71d20b422dc4`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: During ||, this macro contains the table's macro name as top-level expansion. If you are unfamiliar with ``top-level-expansions'' and `||', you will probably never need this macro. Advances users may benefit from expressions like ||. For tables which have been loaded from disk (and have no explicitly assigned macro name), this expands to a temporary macro.

---

## 196. Command: `\newcolumntype\marg{letter`

**ID**: `388acc2728c2`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: number of arguments$&gt;$before columncolumn type$&lt;$after column &#125; The command || is part of the |array| package and it defines a new column type letter for use in tabular environments. codeexample[code only] array codeexample codeexample[] d&#123;&gt;&#123;-&#125;c&lt;&#123;+&#125;&#125; tabular&#123;dl&#125; a & b \\ c & d \\ tabular codeexample Now, the environment |pgfplotstablecoltype| can be used in before column and after column to define numerical columns: codeexample[] L[1] &#123;&gt;&#123;pgfplotstablecoltype[#1]&#125;r&lt;&#123;pgfplotstablecoltype&#125;&#125; tabular

---

## 197. Command: `\pgfmathprintnumber\marg{x`

**ID**: `700dd3df72d4`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: &#125; Generates pretty-printed output for the (real) number x. The input number x is parsed using || which allows arbitrary precision. Numbers are typeset in math mode using the current set of number printing options, see below. Optional arguments can also be provided using |[|options|]|x.

---

## 198. Command: `\pgfmathprintnumberto\marg{x`

**ID**: `1c637e2c1348`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: macro&#125; Returns the resulting number into macro instead of typesetting it directly.

---

## 199. Command: `\pgfmathifisint\marg{number constant`

**ID**: `1477dcae5662`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: true codefalse code&#125; A command which does the same check as |int detect|, but it invokes true code if the number constant actually is an integer and the false code if not. As a side-effect, || will contain the parsed number, either in integer format or as parsed floating point number. The argument number constant will be parsed with ||. codeexample[] 15 15&#123;is an int: .&#125;&#123;is no int&#125;1em 15.5 15.5&#123;is an int: .&#125;&#123;is no int&#125; codeexample

---

## 200. Command: `\year`

**ID**: `d9a23abb825e`  
**Package**: pgfplots  
**Type**: Command Specification  

**Description**: Inside of date format, this macro expands to the year as a number (like |2008|).

---


[← Previous](command-page-002) | Page 4 of 23 | [Next →](command-page-004)
